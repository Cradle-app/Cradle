import type { z } from 'zod';
import type { StylusContractConfig } from '@dapp-forge/blueprint-schema';
import { renderTemplate, dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof StylusContractConfig>;

/**
 * Generate Cargo.toml for Stylus contract
 */
export function generateCargoToml(config: Config): string {
  const crateName = config.contractName.toLowerCase().replace(/([A-Z])/g, '_$1').replace(/^_/, '');
  
  return dedent(`
    [package]
    name = "${crateName}"
    version = "0.1.0"
    edition = "2021"
    license = "MIT"

    [lib]
    crate-type = ["cdylib"]

    [dependencies]
    stylus-sdk = "0.5"
    alloy-primitives = "0.6"
    alloy-sol-types = "0.6"
    mini-alloc = "0.4"

    [features]
    default = []
    export-abi = ["stylus-sdk/export-abi"]

    [profile.release]
    codegen-units = 1
    strip = true
    lto = true
    panic = "abort"
    opt-level = "s"

    [dev-dependencies]
    tokio = { version = "1", features = ["full"] }
  `);
}

/**
 * Generate main contract code
 */
export function generateContractCode(config: Config): string {
  const features = new Set(config.features);
  
  // Build imports
  const imports = [
    'stylus_sdk::{alloy_primitives::{Address, U256}, prelude::*, storage::*}',
  ];

  if (features.has('ownable')) {
    imports.push('stylus_sdk::msg');
  }

  // Build storage struct
  let storageFields = '';
  let implMethods = '';

  // Add base contract storage and methods
  switch (config.contractType) {
    case 'erc20':
      storageFields += generateERC20Storage();
      implMethods += generateERC20Methods(config);
      break;
    case 'erc721':
      storageFields += generateERC721Storage();
      implMethods += generateERC721Methods(config);
      break;
    case 'erc1155':
      storageFields += generateERC1155Storage();
      implMethods += generateERC1155Methods(config);
      break;
    case 'custom':
    default:
      storageFields += '    // Add your custom storage fields here\n';
      implMethods += generateCustomMethods(config);
      break;
  }

  // Add feature-specific storage and methods
  if (features.has('ownable')) {
    storageFields += '    owner: StorageAddress,\n';
    implMethods += generateOwnableMethods();
  }

  if (features.has('pausable')) {
    storageFields += '    paused: StorageBool,\n';
    implMethods += generatePausableMethods();
  }

  // Build custom code section
  const customSection = config.customCode ? `
// Custom code
${config.customCode}
` : '';

  return dedent(`
    // ${config.contractName} - Stylus Smart Contract
    // Generated by Cradle
    
    #![cfg_attr(not(feature = "export-abi"), no_main)]
    extern crate alloc;
    
    use ${imports.join(',\n    ')};
    
    #[global_allocator]
    static ALLOC: mini_alloc::MiniAlloc = mini_alloc::MiniAlloc::INIT;
    
    sol_storage! {
        #[entrypoint]
        pub struct ${config.contractName} {
    ${storageFields}    }
    }
    
    #[public]
    impl ${config.contractName} {
    ${implMethods}}
    ${customSection}
  `);
}

function generateERC20Storage(): string {
  return `        total_supply: StorageU256,
        balances: StorageMap<Address, StorageU256>,
        allowances: StorageMap<Address, StorageMap<Address, StorageU256>>,
        name: StorageString,
        symbol: StorageString,
        decimals: StorageU8,
`;
}

function generateERC20Methods(_config: Config): string {
  return `    /// Returns the total supply of tokens
    pub fn total_supply(&self) -> U256 {
        self.total_supply.get()
    }

    /// Returns the balance of the given account
    pub fn balance_of(&self, account: Address) -> U256 {
        self.balances.get(account)
    }

    /// Returns the allowance of spender for owner
    pub fn allowance(&self, owner: Address, spender: Address) -> U256 {
        self.allowances.get(owner).get(spender)
    }

    /// Transfers tokens to the given recipient
    pub fn transfer(&mut self, to: Address, amount: U256) -> bool {
        let sender = msg::sender();
        self._transfer(sender, to, amount);
        true
    }

    /// Approves the spender to spend the given amount
    pub fn approve(&mut self, spender: Address, amount: U256) -> bool {
        let owner = msg::sender();
        self.allowances.setter(owner).insert(spender, amount);
        true
    }

    /// Transfers tokens from one account to another using allowance
    pub fn transfer_from(&mut self, from: Address, to: Address, amount: U256) -> bool {
        let spender = msg::sender();
        let current_allowance = self.allowances.get(from).get(spender);
        assert!(current_allowance >= amount, "Insufficient allowance");
        
        self.allowances.setter(from).insert(spender, current_allowance - amount);
        self._transfer(from, to, amount);
        true
    }

    /// Internal transfer function
    fn _transfer(&mut self, from: Address, to: Address, amount: U256) {
        let from_balance = self.balances.get(from);
        assert!(from_balance >= amount, "Insufficient balance");
        
        self.balances.insert(from, from_balance - amount);
        let to_balance = self.balances.get(to);
        self.balances.insert(to, to_balance + amount);
    }

`;
}

function generateERC721Storage(): string {
  return `        owners: StorageMap<U256, StorageAddress>,
        balances: StorageMap<Address, StorageU256>,
        token_approvals: StorageMap<U256, StorageAddress>,
        operator_approvals: StorageMap<Address, StorageMap<Address, StorageBool>>,
        name: StorageString,
        symbol: StorageString,
        next_token_id: StorageU256,
`;
}

function generateERC721Methods(_config: Config): string {
  return `    /// Returns the number of NFTs owned by the address
    pub fn balance_of(&self, owner: Address) -> U256 {
        self.balances.get(owner)
    }

    /// Returns the owner of the given token ID
    pub fn owner_of(&self, token_id: U256) -> Address {
        let owner = self.owners.get(token_id);
        assert!(owner != Address::ZERO, "Token does not exist");
        owner
    }

    /// Safely transfers a token from one address to another
    pub fn safe_transfer_from(&mut self, from: Address, to: Address, token_id: U256) {
        self._transfer(from, to, token_id);
    }

    /// Approves another address to transfer the given token
    pub fn approve(&mut self, to: Address, token_id: U256) {
        let owner = self.owners.get(token_id);
        assert!(msg::sender() == owner, "Not the owner");
        self.token_approvals.insert(token_id, to);
    }

    /// Mints a new token to the given address
    pub fn mint(&mut self, to: Address) -> U256 {
        let token_id = self.next_token_id.get();
        self.next_token_id.set(token_id + U256::from(1));
        
        self.owners.insert(token_id, to);
        let balance = self.balances.get(to);
        self.balances.insert(to, balance + U256::from(1));
        
        token_id
    }

    /// Internal transfer function
    fn _transfer(&mut self, from: Address, to: Address, token_id: U256) {
        let owner = self.owners.get(token_id);
        assert!(owner == from, "Not the owner");
        
        self.owners.insert(token_id, to);
        let from_balance = self.balances.get(from);
        self.balances.insert(from, from_balance - U256::from(1));
        let to_balance = self.balances.get(to);
        self.balances.insert(to, to_balance + U256::from(1));
    }

`;
}

function generateERC1155Storage(): string {
  return `        balances: StorageMap<U256, StorageMap<Address, StorageU256>>,
        operator_approvals: StorageMap<Address, StorageMap<Address, StorageBool>>,
        uri: StorageString,
`;
}

function generateERC1155Methods(_config: Config): string {
  return `    /// Returns the balance of an account for a specific token ID
    pub fn balance_of(&self, account: Address, id: U256) -> U256 {
        self.balances.get(id).get(account)
    }

    /// Transfers tokens from one account to another
    pub fn safe_transfer_from(
        &mut self,
        from: Address,
        to: Address,
        id: U256,
        amount: U256,
        _data: Vec<u8>
    ) {
        assert!(msg::sender() == from, "Not authorized");
        
        let from_balance = self.balances.get(id).get(from);
        assert!(from_balance >= amount, "Insufficient balance");
        
        self.balances.setter(id).insert(from, from_balance - amount);
        let to_balance = self.balances.get(id).get(to);
        self.balances.setter(id).insert(to, to_balance + amount);
    }

    /// Mints new tokens to an address
    pub fn mint(&mut self, to: Address, id: U256, amount: U256) {
        let balance = self.balances.get(id).get(to);
        self.balances.setter(id).insert(to, balance + amount);
    }

`;
}

function generateCustomMethods(config: Config): string {
  return `    /// Initialize the contract
    pub fn initialize(&mut self) {
        // Add your initialization logic here
    }

    /// Example function - replace with your own
    pub fn example_function(&self) -> U256 {
        U256::from(42)
    }

`;
}

function generateOwnableMethods(): string {
  return `    /// Returns the owner address
    pub fn owner(&self) -> Address {
        self.owner.get()
    }

    /// Transfers ownership to a new address
    pub fn transfer_ownership(&mut self, new_owner: Address) {
        assert!(msg::sender() == self.owner.get(), "Not the owner");
        assert!(new_owner != Address::ZERO, "Invalid new owner");
        self.owner.set(new_owner);
    }

    /// Modifier-like check for owner-only functions
    fn only_owner(&self) {
        assert!(msg::sender() == self.owner.get(), "Not the owner");
    }

`;
}

function generatePausableMethods(): string {
  return `    /// Returns whether the contract is paused
    pub fn paused(&self) -> bool {
        self.paused.get()
    }

    /// Pauses the contract (owner only)
    pub fn pause(&mut self) {
        self.only_owner();
        self.paused.set(true);
    }

    /// Unpauses the contract (owner only)
    pub fn unpause(&mut self) {
        self.only_owner();
        self.paused.set(false);
    }

    /// Modifier-like check to ensure contract is not paused
    fn when_not_paused(&self) {
        assert!(!self.paused.get(), "Contract is paused");
    }

`;
}

/**
 * Generate test file for the contract
 */
export function generateTestFile(config: Config): string {
  return dedent(`
    // Integration tests for ${config.contractName}
    // Generated by Cradle

    use ${config.contractName.toLowerCase()}::*;

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_contract_initialization() {
            // Add your initialization tests here
            assert!(true, "Contract should initialize correctly");
        }

        ${config.contractType === 'erc20' ? `
        #[test]
        fn test_erc20_transfer() {
            // Test ERC-20 transfer functionality
            // This is a placeholder - implement with actual test logic
            assert!(true, "Transfer should work");
        }

        #[test]
        fn test_erc20_approve_and_transfer_from() {
            // Test ERC-20 approve and transferFrom
            assert!(true, "Approve and transferFrom should work");
        }
        ` : ''}

        ${config.contractType === 'erc721' ? `
        #[test]
        fn test_erc721_mint() {
            // Test ERC-721 minting
            assert!(true, "Minting should work");
        }

        #[test]
        fn test_erc721_transfer() {
            // Test ERC-721 transfer
            assert!(true, "Transfer should work");
        }
        ` : ''}

        ${config.features.includes('ownable') ? `
        #[test]
        fn test_ownership() {
            // Test ownership functionality
            assert!(true, "Ownership should be transferable");
        }
        ` : ''}

        ${config.features.includes('pausable') ? `
        #[test]
        fn test_pause_unpause() {
            // Test pause/unpause functionality
            assert!(true, "Pause/unpause should work");
        }
        ` : ''}
    }
  `);
}

