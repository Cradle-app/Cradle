import type { z } from 'zod';
import type { ERC8004AgentConfig, BlueprintConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof ERC8004AgentConfig>;

/**
 * Generate agent types
 */
export function generateAgentTypes(config: Config): string {
  return dedent(`
    // Agent Types for ${config.agentName}
    // Generated by Cradle

    export type AgentCapability = ${config.capabilities.map(c => `'${c}'`).join(' | ')};

    export interface AgentMetadata {
      name: string;
      version: string;
      capabilities: AgentCapability[];
      registryAddress?: string;
      stakeAmount?: string;
    }

    export interface AgentInvokeRequest {
      prompt: string;
      capability: AgentCapability;
      context?: Record<string, unknown>;
      maxTokens?: number;
      temperature?: number;
    }

    export interface AgentInvokeResponse {
      success: boolean;
      result?: string;
      error?: string;
      usage?: {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
      };
      metadata?: {
        capability: AgentCapability;
        latencyMs: number;
        model: string;
      };
    }

    export interface AgentStatus {
      name: string;
      version: string;
      capabilities: AgentCapability[];
      isRegistered: boolean;
      registryAddress?: string;
      stakeAmount?: string;
      uptime: number;
      requestsHandled: number;
      rateLimits: {
        requestsPerMinute: number;
        tokensPerMinute: number;
        currentRequests: number;
        currentTokens: number;
      };
    }

    export interface RegistryAgentInfo {
      agentId: string;
      owner: string;
      name: string;
      version: string;
      capabilities: string[];
      stake: bigint;
      reputation: bigint;
      isActive: boolean;
      registeredAt: bigint;
    }

    // Rate limiting types
    export interface RateLimitConfig {
      requestsPerMinute: number;
      tokensPerMinute: number;
    }

    export interface RateLimitState {
      requests: number[];
      tokens: number[];
    }

    // Model provider types
    export type ModelProvider = 'openai' | 'anthropic' | 'local' | 'custom';

    export interface ModelConfig {
      provider: ModelProvider;
      model: string;
      apiKey?: string;
      baseUrl?: string;
    }
  `);
}

/**
 * Generate agent configuration
 */
export function generateAgentConfig(config: Config): string {
  const modelMap: Record<string, string> = {
    openai: 'gpt-4-turbo-preview',
    anthropic: 'claude-3-opus-20240229',
    local: 'llama-2-70b',
    custom: 'custom-model',
  };

  return dedent(`
    // Agent Configuration for ${config.agentName}
    // Generated by Cradle

    import type { AgentMetadata, RateLimitConfig, ModelConfig, ModelProvider } from './types';

    export const AGENT_CONFIG: AgentMetadata = {
      name: process.env.AGENT_NAME || '${config.agentName}',
      version: '${config.agentVersion}',
      capabilities: [${config.capabilities.map(c => `'${c}'`).join(', ')}],
      ${config.registryIntegration ? `registryAddress: process.env.AGENT_REGISTRY_ADDRESS,` : ''}
      ${config.stakeAmount ? `stakeAmount: process.env.AGENT_STAKE_AMOUNT || '${config.stakeAmount}',` : ''}
    };

    export const RATE_LIMIT_CONFIG: RateLimitConfig = {
      requestsPerMinute: ${config.rateLimit.requestsPerMinute},
      tokensPerMinute: ${config.rateLimit.tokensPerMinute},
    };

    export const MODEL_CONFIG: ModelConfig = {
      provider: '${config.modelProvider}' as ModelProvider,
      model: '${modelMap[config.modelProvider]}',
      ${config.modelProvider === 'openai' ? `apiKey: process.env.OPENAI_API_KEY,` : ''}
      ${config.modelProvider === 'anthropic' ? `apiKey: process.env.ANTHROPIC_API_KEY,` : ''}
      ${config.modelProvider === 'local' ? `baseUrl: process.env.LOCAL_MODEL_URL || 'http://localhost:8080',` : ''}
    };

    export function validateConfig(): void {
      if (!AGENT_CONFIG.name) {
        throw new Error('AGENT_NAME environment variable is required');
      }

      ${config.modelProvider === 'openai' ? `
      if (!MODEL_CONFIG.apiKey) {
        throw new Error('OPENAI_API_KEY environment variable is required');
      }
      ` : ''}

      ${config.modelProvider === 'anthropic' ? `
      if (!MODEL_CONFIG.apiKey) {
        throw new Error('ANTHROPIC_API_KEY environment variable is required');
      }
      ` : ''}

      ${config.registryIntegration ? `
      if (!AGENT_CONFIG.registryAddress) {
        console.warn('AGENT_REGISTRY_ADDRESS not set - running without registry');
      }
      ` : ''}
    }
  `);
}

/**
 * Generate agent runtime
 */
export function generateAgentRuntime(config: Config): string {
  return dedent(`
    // Agent Runtime for ${config.agentName}
    // Generated by Cradle

    import Fastify from 'fastify';
    import cors from '@fastify/cors';
    import {
      type AgentInvokeRequest,
      type AgentInvokeResponse,
      type AgentStatus,
      type RateLimitState,
      type AgentCapability,
    } from './types';
    import { AGENT_CONFIG, RATE_LIMIT_CONFIG, MODEL_CONFIG, validateConfig } from './config';
    ${config.registryIntegration ? `import { checkRegistration } from './registry';` : ''}

    // Validate configuration on startup
    validateConfig();

    const fastify = Fastify({ logger: true });

    // State
    let startTime = Date.now();
    let requestsHandled = 0;
    const rateLimitState: RateLimitState = {
      requests: [],
      tokens: [],
    };

    // Register plugins
    fastify.register(cors, { origin: true });

    // Rate limiting middleware
    function checkRateLimit(): { allowed: boolean; error?: string } {
      const now = Date.now();
      const oneMinuteAgo = now - 60000;

      // Clean old entries
      rateLimitState.requests = rateLimitState.requests.filter(t => t > oneMinuteAgo);
      rateLimitState.tokens = rateLimitState.tokens.filter(t => t > oneMinuteAgo);

      if (rateLimitState.requests.length >= RATE_LIMIT_CONFIG.requestsPerMinute) {
        return { allowed: false, error: 'Rate limit exceeded: too many requests' };
      }

      return { allowed: true };
    }

    function recordUsage(tokens: number): void {
      const now = Date.now();
      rateLimitState.requests.push(now);
      for (let i = 0; i < tokens; i++) {
        rateLimitState.tokens.push(now);
      }
    }

    // Model invocation
    async function invokeModel(
      prompt: string,
      capability: AgentCapability,
      options: { maxTokens?: number; temperature?: number }
    ): Promise<{ result: string; usage: { promptTokens: number; completionTokens: number } }> {
      const maxTokens = options.maxTokens || 1000;
      const temperature = options.temperature || 0.7;

      ${config.modelProvider === 'openai' ? `
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': \`Bearer \${MODEL_CONFIG.apiKey}\`,
        },
        body: JSON.stringify({
          model: MODEL_CONFIG.model,
          messages: [
            { role: 'system', content: \`You are an AI agent with capability: \${capability}\` },
            { role: 'user', content: prompt },
          ],
          max_tokens: maxTokens,
          temperature,
        }),
      });

      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error?.message || 'OpenAI API error');
      }

      return {
        result: data.choices[0].message.content,
        usage: {
          promptTokens: data.usage.prompt_tokens,
          completionTokens: data.usage.completion_tokens,
        },
      };
      ` : config.modelProvider === 'anthropic' ? `
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': MODEL_CONFIG.apiKey!,
          'anthropic-version': '2024-01-01',
        },
        body: JSON.stringify({
          model: MODEL_CONFIG.model,
          max_tokens: maxTokens,
          messages: [{ role: 'user', content: prompt }],
          system: \`You are an AI agent with capability: \${capability}\`,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error?.message || 'Anthropic API error');
      }

      return {
        result: data.content[0].text,
        usage: {
          promptTokens: data.usage.input_tokens,
          completionTokens: data.usage.output_tokens,
        },
      };
      ` : `
      // Local/custom model implementation
      const response = await fetch(\`\${MODEL_CONFIG.baseUrl}/v1/completions\`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          max_tokens: maxTokens,
          temperature,
        }),
      });

      const data = await response.json();
      
      return {
        result: data.choices[0].text,
        usage: {
          promptTokens: Math.ceil(prompt.length / 4),
          completionTokens: Math.ceil(data.choices[0].text.length / 4),
        },
      };
      `}
    }

    // Routes
    fastify.post<{ Body: AgentInvokeRequest }>('/agent/invoke', async (request, reply) => {
      const startMs = Date.now();
      const { prompt, capability, context, maxTokens, temperature } = request.body;

      // Validate capability
      if (!AGENT_CONFIG.capabilities.includes(capability)) {
        return reply.status(400).send({
          success: false,
          error: \`Unsupported capability: \${capability}. Supported: \${AGENT_CONFIG.capabilities.join(', ')}\`,
        } as AgentInvokeResponse);
      }

      // Check rate limit
      const rateCheck = checkRateLimit();
      if (!rateCheck.allowed) {
        return reply.status(429).send({
          success: false,
          error: rateCheck.error,
        } as AgentInvokeResponse);
      }

      try {
        const { result, usage } = await invokeModel(prompt, capability, { maxTokens, temperature });
        
        recordUsage(usage.promptTokens + usage.completionTokens);
        requestsHandled++;

        const latencyMs = Date.now() - startMs;

        return {
          success: true,
          result,
          usage: {
            promptTokens: usage.promptTokens,
            completionTokens: usage.completionTokens,
            totalTokens: usage.promptTokens + usage.completionTokens,
          },
          metadata: {
            capability,
            latencyMs,
            model: MODEL_CONFIG.model,
          },
        } as AgentInvokeResponse;
      } catch (error) {
        return reply.status(500).send({
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error',
        } as AgentInvokeResponse);
      }
    });

    fastify.get('/agent/status', async () => {
      const now = Date.now();
      const oneMinuteAgo = now - 60000;

      ${config.registryIntegration ? `
      let isRegistered = false;
      try {
        const regStatus = await checkRegistration();
        isRegistered = regStatus.isRegistered;
      } catch {
        isRegistered = false;
      }
      ` : 'const isRegistered = false;'}

      return {
        name: AGENT_CONFIG.name,
        version: AGENT_CONFIG.version,
        capabilities: AGENT_CONFIG.capabilities,
        isRegistered,
        ${config.registryIntegration ? `registryAddress: AGENT_CONFIG.registryAddress,` : ''}
        ${config.stakeAmount ? `stakeAmount: AGENT_CONFIG.stakeAmount,` : ''}
        uptime: now - startTime,
        requestsHandled,
        rateLimits: {
          requestsPerMinute: RATE_LIMIT_CONFIG.requestsPerMinute,
          tokensPerMinute: RATE_LIMIT_CONFIG.tokensPerMinute,
          currentRequests: rateLimitState.requests.filter(t => t > oneMinuteAgo).length,
          currentTokens: rateLimitState.tokens.filter(t => t > oneMinuteAgo).length,
        },
      } as AgentStatus;
    });

    fastify.get('/agent/health', async () => {
      return { status: 'ok', timestamp: new Date().toISOString() };
    });

    // Start server
    const start = async () => {
      try {
        const port = parseInt(process.env.AGENT_PORT || '3002');
        await fastify.listen({ port, host: '0.0.0.0' });
        startTime = Date.now();
        console.log(\`Agent "\${AGENT_CONFIG.name}" v\${AGENT_CONFIG.version} running on port \${port}\`);
        console.log(\`Capabilities: \${AGENT_CONFIG.capabilities.join(', ')}\`);
      } catch (err) {
        fastify.log.error(err);
        process.exit(1);
      }
    };

    start();
  `);
}

/**
 * Generate ERC-8004 registry integration
 */
export function generateAgentRegistry(config: Config, blueprintConfig: BlueprintConfig): string {
  return dedent(`
    // ERC-8004 Registry Integration for ${config.agentName}
    // Generated by Cradle

    import { createPublicClient, createWalletClient, http, parseAbi } from 'viem';
    import { privateKeyToAccount } from 'viem/accounts';
    import { arbitrum, arbitrumSepolia } from 'viem/chains';
    import type { RegistryAgentInfo } from './types';
    import { AGENT_CONFIG } from './config';

    // ERC-8004 Registry ABI (minimal)
    const REGISTRY_ABI = parseAbi([
      'function registerAgent(string name, string version, string[] capabilities) external payable returns (bytes32)',
      'function updateCapabilities(bytes32 agentId, string[] capabilities) external',
      'function getAgent(bytes32 agentId) external view returns (tuple(address owner, string name, string version, string[] capabilities, uint256 stake, uint256 reputation, bool isActive, uint256 registeredAt))',
      'function getAgentByOwner(address owner) external view returns (bytes32)',
      'function stake(bytes32 agentId) external payable',
      'function withdraw(bytes32 agentId, uint256 amount) external',
      'event AgentRegistered(bytes32 indexed agentId, address indexed owner, string name)',
    ]);

    const chain = ${blueprintConfig.network.chainId === 42161 ? 'arbitrum' : 'arbitrumSepolia'};

    function getClients() {
      const publicClient = createPublicClient({
        chain,
        transport: http(),
      });

      const privateKey = process.env.AGENT_PRIVATE_KEY;
      if (!privateKey) {
        throw new Error('AGENT_PRIVATE_KEY environment variable is required');
      }

      const account = privateKeyToAccount(privateKey as \`0x\${string}\`);
      const walletClient = createWalletClient({
        account,
        chain,
        transport: http(),
      });

      return { publicClient, walletClient, account };
    }

    export async function registerAgent(): Promise<{ agentId: string; txHash: string }> {
      const { publicClient, walletClient, account } = getClients();
      const registryAddress = AGENT_CONFIG.registryAddress as \`0x\${string}\`;

      if (!registryAddress) {
        throw new Error('AGENT_REGISTRY_ADDRESS environment variable is required');
      }

      console.log(\`Registering agent "\${AGENT_CONFIG.name}" v\${AGENT_CONFIG.version}...\`);
      console.log(\`Capabilities: \${AGENT_CONFIG.capabilities.join(', ')}\`);

      const stakeAmount = AGENT_CONFIG.stakeAmount ? BigInt(AGENT_CONFIG.stakeAmount) : BigInt(0);

      const hash = await walletClient.writeContract({
        address: registryAddress,
        abi: REGISTRY_ABI,
        functionName: 'registerAgent',
        args: [AGENT_CONFIG.name, AGENT_CONFIG.version, AGENT_CONFIG.capabilities as string[]],
        value: stakeAmount,
      });

      console.log(\`Transaction submitted: \${hash}\`);

      const receipt = await publicClient.waitForTransactionReceipt({ hash });
      
      // Extract agentId from event
      const event = receipt.logs.find(log => {
        try {
          // Simple check for AgentRegistered event
          return log.topics[0] === '0x...' // Replace with actual event signature
        } catch {
          return false;
        }
      });

      const agentId = event?.topics[1] || hash; // Fallback to tx hash

      console.log(\`Agent registered successfully!\`);
      console.log(\`Agent ID: \${agentId}\`);
      console.log(\`Transaction: \${hash}\`);

      return { agentId: agentId as string, txHash: hash };
    }

    export async function checkRegistration(): Promise<{ isRegistered: boolean; agentInfo?: RegistryAgentInfo }> {
      const { publicClient, account } = getClients();
      const registryAddress = AGENT_CONFIG.registryAddress as \`0x\${string}\`;

      if (!registryAddress) {
        return { isRegistered: false };
      }

      try {
        const agentId = await publicClient.readContract({
          address: registryAddress,
          abi: REGISTRY_ABI,
          functionName: 'getAgentByOwner',
          args: [account.address],
        });

        if (!agentId || agentId === '0x0000000000000000000000000000000000000000000000000000000000000000') {
          return { isRegistered: false };
        }

        const agentData = await publicClient.readContract({
          address: registryAddress,
          abi: REGISTRY_ABI,
          functionName: 'getAgent',
          args: [agentId],
        }) as [string, string, string, string[], bigint, bigint, boolean, bigint];

        return {
          isRegistered: true,
          agentInfo: {
            agentId: agentId as string,
            owner: agentData[0],
            name: agentData[1],
            version: agentData[2],
            capabilities: agentData[3],
            stake: agentData[4],
            reputation: agentData[5],
            isActive: agentData[6],
            registeredAt: agentData[7],
          },
        };
      } catch (error) {
        console.error('Error checking registration:', error);
        return { isRegistered: false };
      }
    }

    export async function addStake(amount: string): Promise<string> {
      const { publicClient, walletClient, account } = getClients();
      const registryAddress = AGENT_CONFIG.registryAddress as \`0x\${string}\`;

      const agentId = await publicClient.readContract({
        address: registryAddress,
        abi: REGISTRY_ABI,
        functionName: 'getAgentByOwner',
        args: [account.address],
      });

      const hash = await walletClient.writeContract({
        address: registryAddress,
        abi: REGISTRY_ABI,
        functionName: 'stake',
        args: [agentId],
        value: BigInt(amount),
      });

      await publicClient.waitForTransactionReceipt({ hash });
      console.log(\`Stake added: \${amount} wei\`);
      
      return hash;
    }

    // CLI handler
    const command = process.argv[2];

    if (command === 'register') {
      registerAgent()
        .then(() => process.exit(0))
        .catch((err) => {
          console.error('Registration failed:', err);
          process.exit(1);
        });
    } else if (command === 'status') {
      checkRegistration()
        .then((status) => {
          console.log('Registration Status:', status.isRegistered ? 'Registered' : 'Not Registered');
          if (status.agentInfo) {
            console.log('Agent Info:', JSON.stringify(status.agentInfo, (_, v) => 
              typeof v === 'bigint' ? v.toString() : v, 2));
          }
          process.exit(0);
        })
        .catch((err) => {
          console.error('Status check failed:', err);
          process.exit(1);
        });
    }
  `);
}

